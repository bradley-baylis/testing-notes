<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Testing Notes</title>
  <meta name="description" content="Testing Notes">
  <meta name="author" content="Bradley Baylis">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class = "container">
    <h1 class = "text-center">Testing Notes</h1>

    <h2>What is testing and why do we do it?</h2>

    <p>Put simply, testing is the process of confirming that something is working as intended.  It is typical in any creation process,
      for example a chef may taste his or her soup to decide whether it tastes as they hoped or whether it needs more seasoning.  Software
      development in particular benefits from testing, because unlike cooking it rarely follows a very rigid process and the
      end result can take many different forms.
    </p>

    <h2>Why test?</h2>

    <p>The main reason is simply to find bugs.  However, automated tests in particular bring more advantages:</p>

    <ul>
      <li>Discovering bugs quickly after they are introduced, which leads to bring able to change code with confidence, knowing you won't
        accidently break somthing
      </li>
      <li>It can help you understand the requirements of the software better</li>
      <li>Automated tests can function as documentation</li>
      <li>Manual testing can lead to human error</li>
    </ul>

    <h2>Testing Methods</h2>

    <p>The most common form of testing is one that everyone will have done in some context during their life and that is manual testing.
      For us that would likely involve running through our applications flow and checking it all works properly, manually clicking through 
      as the user would.</p>
    
    <p>This is good for smaller projects as creating automated tests is a lot of potential overhead for little gain when it can be easily 
      covered manually.  In other words, it would be overkill. However, manual testing doesn't scale very well and as the application 
      grows manual testing can be extremely time-consuming.  It also becomes more and more likely that human error can occur during testing,
      especially because it can become quite tedious and minds can wander.
    </p>

    <h3>Functional Testing</h3>

    <h4>Unit testing</h4>

    <p>Unit testing is the most granular form of testing and is very narrow in scope.  A unit test tests one specific piece of 
      functionality, often a literal function.  This functionality will be isolated from the rest of the code and ensure that it performs
      its singular job and is unconcerned with the how it fits into the rest of the code.  Unit testing is the base level of testing that
      everything else is built upon.  
    </p>

    <h4>Integration testing</h4>

    <p>Once you have a good amount of unit test coverage and can be confident that the your base units of functionality are working, you
      can make sure they play nicely together.  We combine our simple functionalities together to create a more complex and 
      probably more useful feature then test that feature.  For example, if you have made a calculator program, you could have unit tests to ensure
      the different math functions like add and subtract are working, then integration tests could ensure that sums that combine these 
      different functions still result in a correct answer.  At this stage, we are often testing a single feature of our application 
      isolated from the rest of the codebase.
    </p>

    <p>Some different ways to perform integration testing are:</p>

    <ul>
      <li>Big bang - All units are integrated together and tested simultaneously as opposed to starting with one unit and adding 
        additional units one at a time.  It differs from system testing because it only tests the interactions between the units
        rather than the whole system.
      </li>
      <li>Top down - The units are ordered by priority and then, starting with the highest priority unit and moving down, are integrated
        together and tested.
      </li>
      <li>Bottom up - The same as top down testing except you begin with the lowest priority unit.</li>
      <li>Sandwich/hybrid - Performing both the top down and bottom up approaches, so you can compare them and make sure the results are
        consistant.
      </li>
    </ul>

    <h4>System testing</h4>

    <p>The next step up from integration testing is system testing.  Previously, with unit and integration testing we have been isolating
      the code we're testing from the rest of our codebase, but system testing now concerns our whole application.  It is a black box 
      testing method, because it isn't concerned about how the application does its job, it only cares whether the job is done.  
    </p>

    <h4>Acceptance testing</h4>

    <p>Now we're sure the application is doing something correctly, we need to also make sure the application fulfills the initial 
      requirements or if the focus of the application has drifted away during development. After all, we wouldn't want coffee machine 
      software that only makes a cup of tea, no matter how reliably it makes that tea (or if the tea is any good).
    </p>

    <h3>Non-functional Testing</h3>
    
    <h4>Performance tests</h4>

    <p>If we have performed at the very least the first few testing stages, we will now be confident that we have working software of 
      some sort.  We can now test whether are aplication can continue to perform its functions well under the pressure of heavy traffic.
      This can take a few different forms as outlined below.
    </p>

    <ul>
      <li>Load testing - Does it still work for an amount of requests that we consider acceptable?</li>
      <li>Stress testing - How does it cope when the amount of requests is even higher than our target acceptable traffic level?</li>
      <li>Endurance (soak) testing - How long can it cope with being above the target acceptable traffic level?</li>
      <li>Spike testing - How does it cope with being above the target acceptable traffic level when the traffic all comes within a
        short period?</li>
    </ul>

    <h4>Security tests</h4>

    <p>Security testing involves looking for security vunerabilities in your software.  Some common vunerabilities could be SQL injections,
      famously allowing malicious users to enter SQL commands into an unsanitised input with disasterous results such as user tables being 
      dropped.  Similarly, Javascript injections can also happen in the same way causing the application to run unintended code, which in 
      turn could give attacks useful information.  Code injections aren't limited to these two languages.
    </p>

    <h4>Usability tests</h4>

    <p>Usability tests ensure that the differnets paths through the website are as intuitive as possible for the end user.</p>

    <h4>Compatibility tests</h4>

    <p>Compatibility tests ensure that the application works consistantly in all environments it uses, whether that be different browsers
      or different operating systems.
    </p>

    <h2>White box and black box testing</h2>

    <p>White box testing is testing that is concerned with the internals of the codebase.  Black box testing is the opposite where it
      is only concerned with testing the functionality, which could also be considered as testing from the end user's perspective.  You
      could summarise the difference as white box testng being about the how and black box testing being about the what.
    </p>


    
    <!--<div class = "row">
      <div class = "col-xs-12 col-sm-4">
        <figure class = "figure">
          <a href = "rebase-example initial.png">
            <img src="rebase-example initial mobile.png" class = "example-img" alt = "Rebase example initial state diagram">
          </a>
          <figcaption class = "figure-caption">In this example, we want to rebase commits C6 and C7, so they they are appended to 
            <code>branch2</code>.
          </figcaption>
        </figure>
      </div>
      <div class = "col-xs-12 col-sm-4">
        <figure class = "figure">
          <a href = "rebase-example mid-point.png">
            <img src="rebase-example mid-point mobile.png" class = "example-img" alt = "Rebase example mid-point state diagram">
          </a>
          <figcaption class = "figure-caption">We use <code>git rebase branch2</code> to achieve this.  We don't need to include <code>master
            </code> at the end, because we already have <code>master</code> checked out.
          </figcaption>
        </figure>
      </div>
      <div class = "col-xs-12 col-sm-4">
        <figure class = "figure">
          <a href = "rebase-example end.png">
            <img src="rebase-example end mobile.png" class = "example-img" alt = "Rebase example end state diagram">
          </a>            
          <figcaption class = "figure-caption">Finally, we use <code>git rebase master branch2</code> to move <code>branch2</code>'s pointer
            to the same commit as <code>master</code>.
          </figcaption>
        </figure>
      </div>
    </div>

    <h3>Example use-cases for use cherry-picking or rebasing</h3>
    <p>Edit an old commit:</p>
    <ul>
      <li>Rebase method
        <ol>
          <li><code>git rebase -i</code> to make old commit most recent</li> 
          <li>Make the changes and stage them</li>
          <li><code>git commit --amend</code></li>
          <li><code>git rebase -i</code> again to put commit back in its original location</li>
        </ol>
      </li>
      <li>Cherry-pick method
        <ol>
          <li><code>git cherry-pick &lt;commit-to-be-edited&gt;</code></li> 
          <li>Make the changes and stage them</li>
          <li><code>git commit --amend</code></li>
          <li><code>git rebase</code> or <code>git cherry-pick</code> the commits that came after</li>
        </ol>
      </li>
    </ul>
    <p>Erase debug commits:</p>
    <ul>
      <li>Rebase method
        <ol>
          <li><code>git rebase -i</code> and simply remove intermediate commits</li>
        </ol>
      </li>
      <li>Cherry-pick method
        <ol>
          <li><code>git checkout &lt;original-branch&gt;</code></li> 
          <li><code>git cherry-pick &lt;finished-commit&gt;</code></li>
        </ol>
      </li>
    </ul>-->
    <footer class = "d-flex justify-content-center align-items-center">Bradley Baylis &copy; 2020</footer>  
  </body>
</html>